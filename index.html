<!doctype html>
<html class="no-js" lang="">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="x-ua-compatible" content="ie=edge">
		<title>Point processes in JS</title>
		<meta name="description" content="">
		<meta name="viewport" content="width=device-width, initial-scale=1">

		<link rel="apple-touch-icon" href="apple-touch-icon.png">
		<!-- Place favicon.ico in the root directory -->

		<link rel="stylesheet" href="css/main.css">
		<script src="./scripts/vendor/d3.js"></script>
		<script src="./scripts/vendor/dat.gui.js"></script>
		<script src="./scripts/vendor/lodash.js"></script>
	</head>
	<body>
		<h1>Point processes in JS</h1>
		<script type="text/javascript">
			"use strict";
			var MAX_POINTS;
			var allXs, allYs, allTs, allParents;
			var xs, ys, ts;
			var deathPtr = 0;
			var birthPtr = 0;
			var simTimer;
			var lastTime = performance.now()/1000; //seconds, for sanity
			var immigrationRate = 2.0;
			var maxX = 100;
			var maxY = 100;
			var timeScale = 5;
			var maxAge = 2;
			var spaceScale = 10;
			var stepCtr = 0;
			var stepperHandle;
			var stepperMinInterval = 150; //ms, for JS compatibility
			var stepping = false;
			
			MAX_POINTS = 1024;
			allXs = new Float32Array(MAX_POINTS);
			allYs = new Float32Array(MAX_POINTS);
			allTs = new Float32Array(MAX_POINTS);
			allParents = new Int32Array(MAX_POINTS);
			
			for (var i = 0; i < MAX_POINTS; i++) {
				allXs[i] = -1;
				allYs[i] = -1;
				allTs[i] = -1;
				allParents[i] = -1;
			}
			
			function poissonRVlite(mu) {
				/* quick and dirty fake Poisson,
				using exp sum. 
				http://www.johndcook.com/blog/2010/06/14/generating-poisson-random-values/
				Keep mu small and it will be ok.
				*/
				var k, M, p;
				M = Math.exp(-mu);
				p = 1;
				for (k = 0; p > M; k++) {
					p *= Math.random()
				}
				return k - 1;
			};
			function updatePoints(thisTime) {
				var nImmigrants, timeDelta, oldestTime;
				if (typeof thisTime === "undefined") thisTime = performance.now()/1000
				
				stepCtr += 1;
				timeDelta = thisTime - lastTime;
				oldestTime = thisTime - maxAge * timeScale;
				nImmigrants = poissonRVlite(immigrationRate * timeDelta);
				for (var i = 0; i < nImmigrants; i++) {
					var newX, newY;
					newX = Math.random() * maxX;
					newY = Math.random() * maxY;
					allXs[birthPtr] = newX;
					allYs[birthPtr] = newY;
					allTs[birthPtr] = thisTime;
					console.debug("birthPtr", birthPtr, allTs[birthPtr])
					birthPtr = birthPtr + 1 % MAX_POINTS;
				};
				// console.debug(
				// 	"deathPtr", deathPtr,
				// 	allTs[deathPtr], ">", oldestTime,
				// 	allTs[deathPtr] - oldestTime)
				for (var i=-1; i<MAX_POINTS;i++) {
					var nextDeathPtr = (deathPtr+1)%MAX_POINTS;
					var nextPointTime = allTs[nextDeathPtr];
					if ((nextPointTime==-1) ||
							(nextPointTime>oldestTime)) {
						break;
					} else {
						deathPtr = nextDeathPtr;
						console.debug(
							"==>deathPtr", deathPtr,
							nextPointTime, "<", oldestTime)
					}
				};
				lastTime = thisTime;
			};
			function getPoints(thisTime) {
				var currXs, currYs, currAges;
				var nPoints = (MAX_POINTS + birthPtr - deathPtr) % MAX_POINTS;
				//can I do this with views over pre alloced arrays?
				currXs = new Float32Array(nPoints);
				currYs = new Float32Array(nPoints);
				currAges = new Float32Array(nPoints);
				
				if (typeof thisTime === "undefined") thisTime = performance.now()/1000
				for (var j = 0; j < nPoints; j++) {
					var i = (j + deathPtr) % MAX_POINTS;
					currXs[j] = allXs[i];
					currYs[j] = allYs[i];
					currAges[j] = thisTime - allTs[i]
				};
				return {
					x: currXs,
					y: currYs,
					age: currAges,
				};
			};
			
			function stepAndSchedule() {
				var ret = updatePoints();
				stepperHandle = window.setTimeout(
					stepAndSchedule, stepperMinInterval
				);
			};
			function startSim() {
				stepAndSchedule();
			};
			function stopSim() {
				window.clearTimeout(stepperHandle);
			};
			startSim();
		</script>
	</body>
</html>
